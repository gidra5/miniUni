import "std/iter" as { range }
import "std/concurrency" as { wait, sync, all, pipe }
import "std/math" as { random }


create_packet := fn (id, target_id, msg) { id: id, target_id: target_id, msg: msg }
create_router := fn id, connections {
  chan := channel("router " + string id)

  async loop {
    // introduce latency
    wait(1000 + random() * 500)
    
    // handle incoming packets
    switch <- chan {
      // if packet target was this router, handle message
      { target_id: ^id, msg } -> print("router " + string id + " received message: " + msg),

      // otherwise send to other routers
      { target_id, id: packet_id } @ packet -> {
        // try sending directly to target
        status := connections.find({ id } -> target_id == id).chan ?<- packet

        if status == :pending {
          // if target is busy, try routers one by one in random order
          // until someone is free
          loop {
            router := connections.pick_random()
            status := router.chan ?<- packet
            if status != :pending {
              print(
                "packet " + string packet_id + 
                " sent from " + string id + 
                " to " + string router.id
              )
              break()
            }
          }
        } else {
          print("packet " + string packet_id + 
          " sent from " + string id + 
          " to target")
        }
      }
    }
  }

  chan
}

create_network_node := fn id {
  print("creating node " + string id)
  connections := ()
  chan := create_router id connections
  
  id: id, connections: connections, chan: chan
}

create_network := fn size {
  print "populate network with nodes"
  network := for id in range 0 size do create_network_node id
  
  print "connect all the nodes together"
  all for from in network do async {
    print("connecting node " + string from.id)
    _network := network.filter({ id } -> id != from.id)
    for to in _network {
      chan_name := "connection " + string from.id + ":" + string to.id
      from.connections[from.connections.length] = id: to.id, chan: pipe (channel chan_name) to.chan
    }
  }

  network
}

export fn do sync {
  print "creating network"
  network := create_network 9

  print "simulating package routing"

  // generate 10 packets to send through the network
  for i in range 0 10 {
    packageName := "package " + string i

    node_from := network[0]
    node_to := network.pick_random()

    print(
      "sending " + packageName + 
      " to " + string node_to.id
    ) 

    packet := create_packet(i, node_to.id, packageName)
    async node_from.chan <- packet
  }
}